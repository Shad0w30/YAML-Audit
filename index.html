<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Security Scanner</title>
    <script src="https://cdn.jsdelivr.net/npm/js-yaml@4.1.0/dist/js-yaml.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.3.0/papaparse.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
    <style>
        body { font-family: Arial, sans-serif; margin: 20px; }
        textarea { width: 100%; height: 200px; margin-bottom: 10px; }
        button { padding: 8px 15px; margin-right: 10px; margin-bottom: 20px; }
        .tab { overflow: hidden; border: 1px solid #ccc; background-color: #f1f1f1; }
        .tab button { background-color: inherit; float: left; border: none; outline: none; cursor: pointer; padding: 14px 16px; transition: 0.3s; }
        .tab button:hover { background-color: #ddd; }
        .tab button.active { background-color: #ccc; }
        .tabcontent { display: none; padding: 6px 12px; border: 1px solid #ccc; border-top: none; }
        table { width: 100%; border-collapse: collapse; margin-top: 20px; }
        th, td { border: 1px solid #ddd; padding: 8px; text-align: left; }
        th { background-color: #f2f2f2; }
        tr:nth-child(even) { background-color: #f9f9f9; }
        .Critical { background-color: #ffcccc; }
        .High { background-color: #ffddcc; }
        .Medium { background-color: #fff2cc; }
        .Low { background-color: #e6ffe6; }
        .Info { background-color: #e6f3ff; }
        .line-highlight { background-color: #ffff99; font-weight: bold; }
        .summary-card { 
            padding: 15px; 
            margin-bottom: 20px; 
            border-radius: 5px; 
            box-shadow: 0 2px 5px rgba(0,0,0,0.1); 
            display: flex; 
            justify-content: space-between;
        }
        .summary-item { text-align: center; padding: 10px; }
        .summary-count { font-size: 24px; font-weight: bold; }
        .summary-label { font-size: 14px; }
        pre { 
            background-color: #f5f5f5;
            padding: 10px;
            border-radius: 4px;
            overflow-x: auto;
        }
        .snippet-row td { padding: 0; }
        .snippet-row pre { margin: 0; border: none; border-radius: 0; }
    </style>
</head>
<body>
    <h1>Security Scanner</h1>
    
    <div class="tab">
        <button class="tablinks active" onclick="openTab(event, 'inputTab')">Input</button>
        <button class="tablinks" onclick="openTab(event, 'resultsTab')">Results</button>
        <button class="tablinks" onclick="openTab(event, 'fixesTab')">Auto-Fixes</button>
    </div>
    
    <div id="inputTab" class="tabcontent" style="display: block;">
        <p>Paste your Kubernetes YAML or JSON configuration below:</p>
        <textarea id="configInput" placeholder="Paste YAML or JSON here..."></textarea>
        <div>
            <button onclick="scanConfig()">Scan Configuration</button>
            <select id="inputType">
                <option value="yaml">YAML</option>
                <option value="json">JSON</option>
            </select>
            <button onclick="loadSample()">Load Sample</button>
        </div>
    </div>
    
    <div id="resultsTab" class="tabcontent">
        <div id="summary"></div>
        <div id="results"></div>
        <button onclick="downloadCSV()">Download as CSV</button>
        <button onclick="downloadExcel()">Download as Excel</button>
    </div>
    
    <div id="fixesTab" class="tabcontent">
        <h2>Auto-Fixes</h2>
        <div id="autoFixes"></div>
        <button onclick="downloadAutoFixes()">Download Fixed Config</button>
    </div>

    <script>
        // Global variables
        const CIS_MAP = {
            privileged: { id: 'CIS 5.2.1', title: 'Privileged Container' },
            allowPrivilegeEscalation: { id: 'CIS 5.2.6', title: 'Allow Privilege Escalation' },
            runAsRoot: { id: 'CIS 5.2.5', title: 'Run as Root User' },
            readOnlyRootFS: { id: 'CIS 5.2.7', title: 'Read-only Root Filesystem' },
            capabilities: { id: 'CIS 5.2.8/5.2.9', title: 'Dangerous Capabilities' },
            resourceLimits: { id: 'CIS 5.1.1', title: 'Resource Limits' },
            resourceLimitsCPU: { id: 'CIS 5.1.2', title: 'CPU Limits' },
            resourceLimitsMemory: { id: 'CIS 5.1.3', title: 'Memory Limits' },
            imageLatestTag: { id: 'CIS 5.4.1', title: 'Latest Image Tag' },
            hostNamespace: { id: 'CIS 5.2.2/5.2.3/5.2.4', title: 'Host Namespace Sharing' },
            defaultServiceAccount: { id: 'CIS 5.1.5', title: 'Default Service Account' },
            hostPathVolume: { id: 'CIS 5.3.6', title: 'HostPath Volume' },
            missingProbes: { id: 'CIS 5.7.4', title: 'Missing Health Probes' },
            networkPolicy: { id: 'CIS 6.3.1', title: 'Network Policy' },
            secretsEnv: { id: 'CIS 5.5.1', title: 'Secrets in Environment Variables' },
            secretsVolume: { id: 'CIS 5.5.2', title: 'Secrets Mounted as Volumes' },
            appArmor: { id: 'CIS 5.2.12', title: 'AppArmor Profile' },
            seccomp: { id: 'CIS 5.2.13', title: 'Seccomp Profile' }
        };

        const SECRET_PATTERNS = [
            { regex: /AKIA[0-9A-Z]{16}/, desc: 'AWS Access Key ID' },
            { regex: /[0-9a-zA-Z/+]{40}/, desc: 'AWS Secret Access Key' },
            { regex: /-----BEGIN (RSA|EC|DSA|PGP) PRIVATE KEY-----/, desc: 'Private Key' },
            { regex: /-----BEGIN CERTIFICATE-----/, desc: 'Certificate' },
            { regex: /eyJhbGciOiJ[^\s"]*/, desc: 'JWT Token' },
            { regex: /(?:password|passwd|pwd|secret|token|key|credential)[^a-zA-Z0-9][^'"\n]*[=:][^'"\n]*/, desc: 'Potential credential' }
        ];

        const DANGEROUS_CAPABILITIES = [
            'ALL', 'NET_ADMIN', 'NET_RAW', 'SYS_ADMIN', 'SYS_MODULE', 
            'SYS_PTRACE', 'SYS_RAWIO', 'SYS_CHROOT', 'DAC_OVERRIDE',
            'FOWNER', 'SETUID', 'SETGID', 'KILL', 'MKNOD'
        ];

        let findings = [];
        let autoFixes = [];
        let originalConfig = '';
        let configLines = [];

        // Tab management
        function openTab(evt, tabName) {
            const tabcontent = document.getElementsByClassName("tabcontent");
            for (let i = 0; i < tabcontent.length; i++) {
                tabcontent[i].style.display = "none";
            }
            
            const tablinks = document.getElementsByClassName("tablinks");
            for (let i = 0; i < tablinks.length; i++) {
                tablinks[i].className = tablinks[i].className.replace(" active", "");
            }
            
            document.getElementById(tabName).style.display = "block";
            evt.currentTarget.className += " active";
        }

        // Load sample configuration
        function loadSample() {
            const sampleYaml = `apiVersion: apps/v1
kind: Deployment
metadata:
  name: nginx-deployment
spec:
  replicas: 3
  selector:
    matchLabels:
      app: nginx
  template:
    metadata:
      labels:
        app: nginx
    spec:
      containers:
      - name: nginx
        image: nginx:latest
        securityContext:
          privileged: true
          allowPrivilegeEscalation: true
          runAsUser: 0
        ports:
        - containerPort: 80
        resources:
          requests:
            cpu: "100m"
            memory: "128Mi"
        env:
        - name: SECRET_KEY
          valueFrom:
            secretKeyRef:
              name: my-secret
              key: secret-key
---
apiVersion: v1
kind: Secret
metadata:
  name: my-secret
type: Opaque
data:
  secret-key: dGhpcy1pcy1hLXNlY3JldC1rZXkK
`;
            document.getElementById('configInput').value = sampleYaml;
            document.getElementById('inputType').value = 'yaml';
        }

        // Main scanning function
        function scanConfig() {
            const configContent = document.getElementById('configInput').value;
            if (!configContent.trim()) {
                alert("Please enter some YAML or JSON content to scan");
                return;
            }
            
            originalConfig = configContent;
            configLines = configContent.split('\n');
            const inputType = document.getElementById('inputType').value;
            
            let docs;
            try {
                if (inputType === 'yaml') {
                    docs = jsyaml.loadAll(configContent);
                } else {
                    docs = [JSON.parse(configContent)];
                }
            } catch (e) {
                alert(`Invalid ${inputType.toUpperCase()}: ${e.message}`);
                return;
            }

            findings = [];
            autoFixes = [];

            docs.forEach((doc, docIndex) => {
                if (!doc || typeof doc !== 'object') return;

                if (doc.kind) {
                    switch(doc.kind.toLowerCase()) {
                        case 'pod':
                            checkPodSecurity(doc);
                            break;
                        case 'deployment':
                        case 'statefulset':
                        case 'daemonset':
                        case 'replicaset':
                        case 'job':
                        case 'cronjob':
                            checkWorkloadSecurity(doc);
                            break;
                        case 'service':
                            checkServiceSecurity(doc);
                            break;
                        case 'ingress':
                            checkIngressSecurity(doc);
                            break;
                        case 'networkpolicy':
                            checkNetworkPolicy(doc);
                            break;
                        case 'role':
                        case 'clusterrole':
                            checkRBACSecurity(doc);
                            break;
                        case 'secret':
                            checkSecretSecurity(doc);
                            break;
                        case 'configmap':
                            checkConfigMapSecurity(doc);
                            break;
                        case 'serviceaccount':
                            checkServiceAccountSecurity(doc);
                            break;
                        default:
                            checkGenericResourceSecurity(doc);
                    }
                } else {
                    checkGenericYamlSecurity(doc);
                }

                scanSecrets(doc);
            });

            renderResults();
            renderAutoFixes();
            openTab(null, 'resultsTab');
        }

        // Security check functions
        function checkPodSecurity(pod) {
            const spec = pod.spec || {};
            checkPodSecurityContext(spec.securityContext, pod);
            
            if (spec.containers) {
                spec.containers.forEach(container => {
                    checkContainerSecurity(container, pod);
                });
            }
            
            if (spec.initContainers) {
                spec.initContainers.forEach(container => {
                    checkContainerSecurity(container, pod);
                });
            }
            
            if (spec.volumes) {
                checkVolumes(spec.volumes, pod);
            }
            
            checkHostNamespaces(spec, pod);
            checkServiceAccount(spec, pod);
        }

        function checkWorkloadSecurity(workload) {
            const template = workload.spec?.template;
            if (template && template.spec) {
                checkPodSecurity({ 
                    kind: 'Pod', 
                    metadata: template.metadata, 
                    spec: template.spec 
                });
            }
        }

        function checkContainerSecurity(container, parentResource) {
            const ctx = container.securityContext || {};
            const lineInfo = findLineInfo(container, 'name', container.name);
            
            if (ctx.privileged) {
                addFinding({
                    id: CIS_MAP.privileged.id,
                    title: CIS_MAP.privileged.title,
                    message: `Container '${container.name}' is running in privileged mode`,
                    severity: 'High',
                    resource: parentResource.metadata?.name || 'Unknown',
                    kind: parentResource.kind || 'Unknown',
                    line: lineInfo.line,
                    column: lineInfo.column,
                    snippet: lineInfo.snippet,
                    remediation: 'Set securityContext.privileged to false'
                });
                
                addAutoFix(parentResource, {
                    path: `/spec/template/spec/containers/[name=${container.name}]/securityContext/privileged`,
                    value: false,
                    op: 'replace'
                });
            }
            
            if (ctx.allowPrivilegeEscalation !== false) {
                addFinding({
                    id: CIS_MAP.allowPrivilegeEscalation.id,
                    title: CIS_MAP.allowPrivilegeEscalation.title,
                    message: `Container '${container.name}' allows privilege escalation`,
                    severity: ctx.allowPrivilegeEscalation ? 'High' : 'Medium',
                    resource: parentResource.metadata?.name || 'Unknown',
                    kind: parentResource.kind || 'Unknown',
                    line: lineInfo.line,
                    column: lineInfo.column,
                    snippet: lineInfo.snippet,
                    remediation: 'Set securityContext.allowPrivilegeEscalation to false'
                });
                
                addAutoFix(parentResource, {
                    path: `/spec/template/spec/containers/[name=${container.name}]/securityContext/allowPrivilegeEscalation`,
                    value: false,
                    op: 'replace'
                });
            }
            
            if (ctx.runAsUser === 0 || ctx.runAsUser === '0') {
                addFinding({
                    id: CIS_MAP.runAsRoot.id,
                    title: CIS_MAP.runAsRoot.title,
                    message: `Container '${container.name}' is running as root user (runAsUser=0)`,
                    severity: 'High',
                    resource: parentResource.metadata?.name || 'Unknown',
                    kind: parentResource.kind || 'Unknown',
                    line: lineInfo.line,
                    column: lineInfo.column,
                    snippet: lineInfo.snippet,
                    remediation: 'Set securityContext.runAsUser to a non-zero value'
                });
                
                addAutoFix(parentResource, {
                    path: `/spec/template/spec/containers/[name=${container.name}]/securityContext/runAsUser`,
                    value: 1000,
                    op: 'replace'
                });
            }
            
            if (ctx.readOnlyRootFilesystem !== true) {
                addFinding({
                    id: CIS_MAP.readOnlyRootFS.id,
                    title: CIS_MAP.readOnlyRootFS.title,
                    message: `Container '${container.name}' does not have a read-only root filesystem`,
                    severity: 'Medium',
                    resource: parentResource.metadata?.name || 'Unknown',
                    kind: parentResource.kind || 'Unknown',
                    line: lineInfo.line,
                    column: lineInfo.column,
                    snippet: lineInfo.snippet,
                    remediation: 'Set securityContext.readOnlyRootFilesystem to true'
                });
                
                addAutoFix(parentResource, {
                    path: `/spec/template/spec/containers/[name=${container.name}]/securityContext/readOnlyRootFilesystem`,
                    value: true,
                    op: 'replace'
                });
            }
            
            if (ctx.capabilities && ctx.capabilities.add) {
                const dangerousCaps = ctx.capabilities.add.filter(cap => 
                    DANGEROUS_CAPABILITIES.includes(cap.toUpperCase())
                );
                
                if (dangerousCaps.length > 0) {
                    addFinding({
                        id: CIS_MAP.capabilities.id,
                        title: CIS_MAP.capabilities.title,
                        message: `Container '${container.name}' has dangerous capabilities: ${dangerousCaps.join(', ')}`,
                        severity: 'High',
                        resource: parentResource.metadata?.name || 'Unknown',
                        kind: parentResource.kind || 'Unknown',
                        line: lineInfo.line,
                        column: lineInfo.column,
                        snippet: lineInfo.snippet,
                        remediation: 'Remove dangerous capabilities from securityContext.capabilities.add'
                    });
                    
                    addAutoFix(parentResource, {
                        path: `/spec/template/spec/containers/[name=${container.name}]/securityContext/capabilities/add`,
                        value: ctx.capabilities.add.filter(cap => 
                            !DANGEROUS_CAPABILITIES.includes(cap.toUpperCase())
                        ),
                        op: 'replace'
                    });
                }
            }
            
            if (!container.resources || !container.resources.limits) {
                addFinding({
                    id: CIS_MAP.resourceLimits.id,
                    title: CIS_MAP.resourceLimits.title,
                    message: `Container '${container.name}' has no resource limits defined`,
                    severity: 'Medium',
                    resource: parentResource.metadata?.name || 'Unknown',
                    kind: parentResource.kind || 'Unknown',
                    line: lineInfo.line,
                    column: lineInfo.column,
                    snippet: lineInfo.snippet,
                    remediation: 'Define resource limits for the container'
                });
                
                addAutoFix(parentResource, {
                    path: `/spec/template/spec/containers/[name=${container.name}]/resources/limits`,
                    value: { cpu: '500m', memory: '512Mi' },
                    op: 'add'
                });
            }
            
            if (!container.livenessProbe || !container.readinessProbe) {
                addFinding({
                    id: CIS_MAP.missingProbes.id,
                    title: CIS_MAP.missingProbes.title,
                    message: `Container '${container.name}' missing liveness/readiness probes`,
                    severity: 'Medium',
                    resource: parentResource.metadata?.name || 'Unknown',
                    kind: parentResource.kind || 'Unknown',
                    line: lineInfo.line,
                    column: lineInfo.column,
                    snippet: lineInfo.snippet,
                    remediation: 'Define health probes for the container'
                });
            }
            
            if (container.image && (container.image.endsWith(':latest') || !container.image.includes(':'))) {
                addFinding({
                    id: CIS_MAP.imageLatestTag.id,
                    title: CIS_MAP.imageLatestTag.title,
                    message: `Container '${container.name}' uses the 'latest' tag or no tag`,
                    severity: 'Medium',
                    resource: parentResource.metadata?.name || 'Unknown',
                    kind: parentResource.kind || 'Unknown',
                    line: lineInfo.line,
                    column: lineInfo.column,
                    snippet: lineInfo.snippet,
                    remediation: 'Use a specific immutable image tag'
                });
            }
            
            if (container.volumeMounts) {
                container.volumeMounts.forEach(mount => {
                    const vol = parentResource.spec?.volumes?.find(v => v.name === mount.name);
                    if (vol?.hostPath) {
                        addFinding({
                            id: CIS_MAP.hostPathVolume.id,
                            title: CIS_MAP.hostPathVolume.title,
                            message: `Container '${container.name}' mounts hostPath volume '${vol.name}' at '${mount.mountPath}'`,
                            severity: 'High',
                            resource: parentResource.metadata?.name || 'Unknown',
                            kind: parentResource.kind || 'Unknown',
                            line: lineInfo.line,
                            column: lineInfo.column,
                            snippet: lineInfo.snippet,
                            remediation: 'Avoid using hostPath volumes'
                        });
                    }
                });
            }
            
            if (container.env) {
                container.env.forEach(envVar => {
                    if (envVar.valueFrom?.secretKeyRef) {
                        addFinding({
                            id: CIS_MAP.secretsEnv.id,
                            title: CIS_MAP.secretsEnv.title,
                            message: `Container '${container.name}' uses secret in environment variable '${envVar.name}'`,
                            severity: 'Medium',
                            resource: parentResource.metadata?.name || 'Unknown',
                            kind: parentResource.kind || 'Unknown',
                            line: lineInfo.line,
                            column: lineInfo.column,
                            snippet: lineInfo.snippet,
                            remediation: 'Consider using secret volumes instead'
                        });
                    }
                });
            }
        }

        function checkPodSecurityContext(ctx, pod) {
            if (!ctx) return;
            
            const lineInfo = findLineInfo(pod.spec, 'securityContext');
            
            if (ctx.runAsNonRoot !== true) {
                addFinding({
                    id: CIS_MAP.runAsRoot.id,
                    title: CIS_MAP.runAsRoot.title,
                    message: 'Pod does not enforce running as non-root user',
                    severity: 'High',
                    resource: pod.metadata?.name || 'Unknown',
                    kind: pod.kind || 'Unknown',
                    line: lineInfo.line,
                    column: lineInfo.column,
                    snippet: lineInfo.snippet,
                    remediation: 'Set securityContext.runAsNonRoot to true'
                });
            }
            
            if (!ctx.seccompProfile || ctx.seccompProfile.type !== 'RuntimeDefault') {
                addFinding({
                    id: CIS_MAP.seccomp.id,
                    title: CIS_MAP.seccomp.title,
                    message: 'Pod does not use the default seccomp profile',
                    severity: 'Medium',
                    resource: pod.metadata?.name || 'Unknown',
                    kind: pod.kind || 'Unknown',
                    line: lineInfo.line,
                    column: lineInfo.column,
                    snippet: lineInfo.snippet,
                    remediation: 'Set securityContext.seccompProfile.type to RuntimeDefault'
                });
            }
        }

        function checkHostNamespaces(spec, pod) {
            const lineInfo = findLineInfo(spec, 'hostNetwork');
            
            if (spec.hostNetwork) {
                addFinding({
                    id: CIS_MAP.hostNamespace.id,
                    title: CIS_MAP.hostNamespace.title,
                    message: 'Pod shares the host network namespace',
                    severity: 'High',
                    resource: pod.metadata?.name || 'Unknown',
                    kind: pod.kind || 'Unknown',
                    line: lineInfo.line,
                    column: lineInfo.column,
                    snippet: lineInfo.snippet,
                    remediation: 'Set hostNetwork to false'
                });
            }
            
            if (spec.hostPID) {
                addFinding({
                    id: CIS_MAP.hostNamespace.id,
                    title: CIS_MAP.hostNamespace.title,
                    message: 'Pod shares the host PID namespace',
                    severity: 'High',
                    resource: pod.metadata?.name || 'Unknown',
                    kind: pod.kind || 'Unknown',
                    line: lineInfo.line,
                    column: lineInfo.column,
                    snippet: lineInfo.snippet,
                    remediation: 'Set hostPID to false'
                });
            }
            
            if (spec.hostIPC) {
                addFinding({
                    id: CIS_MAP.hostNamespace.id,
                    title: CIS_MAP.hostNamespace.title,
                    message: 'Pod shares the host IPC namespace',
                    severity: 'High',
                    resource: pod.metadata?.name || 'Unknown',
                    kind: pod.kind || 'Unknown',
                    line: lineInfo.line,
                    column: lineInfo.column,
                    snippet: lineInfo.snippet,
                    remediation: 'Set hostIPC to false'
                });
            }
        }

        function checkServiceAccount(spec, pod) {
            const lineInfo = findLineInfo(spec, 'serviceAccountName');
            
            if (spec.serviceAccountName === 'default' || !spec.serviceAccountName) {
                addFinding({
                    id: CIS_MAP.defaultServiceAccount.id,
                    title: CIS_MAP.defaultServiceAccount.title,
                    message: 'Pod uses the default service account',
                    severity: 'Medium',
                    resource: pod.metadata?.name || 'Unknown',
                    kind: pod.kind || 'Unknown',
                    line: lineInfo.line,
                    column: lineInfo.column,
                    snippet: lineInfo.snippet,
                    remediation: 'Create a dedicated service account'
                });
            }
            
            if (spec.automountServiceAccountToken !== false) {
                addFinding({
                    id: CIS_MAP.defaultServiceAccount.id,
                    title: CIS_MAP.defaultServiceAccount.title,
                    message: 'Pod automatically mounts the service account token',
                    severity: 'Medium',
                    resource: pod.metadata?.name || 'Unknown',
                    kind: pod.kind || 'Unknown',
                    line: lineInfo.line,
                    column: lineInfo.column,
                    snippet: lineInfo.snippet,
                    remediation: 'Set automountServiceAccountToken to false'
                });
            }
        }

        function checkVolumes(volumes, pod) {
            volumes.forEach(vol => {
                const lineInfo = findLineInfo(vol, 'name', vol.name);
                
                if (vol.hostPath) {
                    addFinding({
                        id: CIS_MAP.hostPathVolume.id,
                        title: CIS_MAP.hostPathVolume.title,
                        message: `Pod uses hostPath volume '${vol.name}'`,
                        severity: 'High',
                        resource: pod.metadata?.name || 'Unknown',
                        kind: pod.kind || 'Unknown',
                        line: lineInfo.line,
                        column: lineInfo.column,
                        snippet: lineInfo.snippet,
                        remediation: 'Avoid using hostPath volumes'
                    });
                }
                
                if (vol.secret) {
                    addFinding({
                        id: CIS_MAP.secretsVolume.id,
                        title: CIS_MAP.secretsVolume.title,
                        message: `Pod mounts secret '${vol.secret.secretName}' as volume '${vol.name}'`,
                        severity: 'Low',
                        resource: pod.metadata?.name || 'Unknown',
                        kind: pod.kind || 'Unknown',
                        line: lineInfo.line,
                        column: lineInfo.column,
                        snippet: lineInfo.snippet,
                        remediation: 'Ensure secret volumes have appropriate permissions'
                    });
                }
            });
        }

        function checkNetworkPolicy(policy) {
            const lineInfo = findLineInfo(policy, 'kind', 'NetworkPolicy');
            
            if (!policy.spec.ingress) {
                addFinding({
                    id: CIS_MAP.networkPolicy.id,
                    title: CIS_MAP.networkPolicy.title,
                    message: 'NetworkPolicy has no ingress rules defined',
                    severity: 'High',
                    resource: policy.metadata?.name || 'Unknown',
                    kind: policy.kind || 'Unknown',
                    line: lineInfo.line,
                    column: lineInfo.column,
                    snippet: lineInfo.snippet,
                    remediation: 'Define specific ingress rules'
                });
            }
            
            if (!policy.spec.egress) {
                addFinding({
                    id: CIS_MAP.networkPolicy.id,
                    title: CIS_MAP.networkPolicy.title,
                    message: 'NetworkPolicy has no egress rules defined',
                    severity: 'Medium',
                    resource: policy.metadata?.name || 'Unknown',
                    kind: policy.kind || 'Unknown',
                    line: lineInfo.line,
                    column: lineInfo.column,
                    snippet: lineInfo.snippet,
                    remediation: 'Define specific egress rules'
                });
            }
        }

        function scanSecrets(doc) {
            const docString = JSON.stringify(doc);
            const lineInfo = findLineInfo(doc, 'kind', doc.kind);
            
            SECRET_PATTERNS.forEach(p => {
                const matches = docString.match(p.regex);
                if (matches) {
                    matches.forEach(match => {
                        addFinding({
                            id: 'Secret-Detection',
                            title: 'Secret Detection',
                            message: `${p.desc}: ${match.substring(0, 20)}...`,
                            severity: 'Critical',
                            resource: doc.metadata?.name || 'Unknown',
                            kind: doc.kind || 'Unknown',
                            line: lineInfo.line,
                            column: lineInfo.column,
                            snippet: lineInfo.snippet,
                            remediation: 'Remove sensitive information from configuration'
                        });
                    });
                }
            });
        }

        function checkServiceSecurity(svc) {
            const lineInfo = findLineInfo(svc, 'kind', 'Service');
            
            if (svc.spec.externalIPs && svc.spec.externalIPs.length > 0) {
                addFinding({
                    id: 'Service-ExternalIPs',
                    title: 'Service with External IPs',
                    message: `Service exposes external IPs: ${svc.spec.externalIPs.join(', ')}`,
                    severity: 'High',
                    resource: svc.metadata?.name || 'Unknown',
                    kind: svc.kind || 'Unknown',
                    line: lineInfo.line,
                    column: lineInfo.column,
                    snippet: lineInfo.snippet,
                    remediation: 'Avoid using externalIPs'
                });
            }
        }

        function checkIngressSecurity(ingress) {
            const lineInfo = findLineInfo(ingress, 'kind', 'Ingress');
            
            if (!ingress.spec.tls || ingress.spec.tls.length === 0) {
                addFinding({
                    id: 'Ingress-TLS',
                    title: 'Ingress without TLS',
                    message: 'Ingress does not enforce TLS encryption',
                    severity: 'High',
                    resource: ingress.metadata?.name || 'Unknown',
                    kind: ingress.kind || 'Unknown',
                    line: lineInfo.line,
                    column: lineInfo.column,
                    snippet: lineInfo.snippet,
                    remediation: 'Configure TLS for the Ingress'
                });
            }
        }

        function checkRBACSecurity(role) {
            const lineInfo = findLineInfo(role, 'kind', role.kind);
            
            if (role.rules) {
                role.rules.forEach(rule => {
                    if (rule.resources && rule.resources.includes('*')) {
                        addFinding({
                            id: 'RBAC-Wildcard',
                            title: 'RBAC Wildcard Resource',
                            message: `${role.kind} allows access to all resources`,
                            severity: 'High',
                            resource: role.metadata?.name || 'Unknown',
                            kind: role.kind || 'Unknown',
                            line: lineInfo.line,
                            column: lineInfo.column,
                            snippet: lineInfo.snippet,
                            remediation: 'Restrict resources to specific types'
                        });
                    }
                    
                    if (rule.verbs && rule.verbs.includes('*')) {
                        addFinding({
                            id: 'RBAC-Wildcard',
                            title: 'RBAC Wildcard Verb',
                            message: `${role.kind} allows all verbs on resources`,
                            severity: 'High',
                            resource: role.metadata?.name || 'Unknown',
                            kind: role.kind || 'Unknown',
                            line: lineInfo.line,
                            column: lineInfo.column,
                            snippet: lineInfo.snippet,
                            remediation: 'Restrict verbs to only those needed'
                        });
                    }
                });
            }
        }

        function checkSecretSecurity(secret) {
            const lineInfo = findLineInfo(secret, 'kind', 'Secret');
            
            if (secret.type === 'Opaque' && secret.data) {
                Object.keys(secret.data).forEach(key => {
                    try {
                        atob(secret.data[key]);
                    } catch (e) {
                        addFinding({
                            id: 'Secret-Encoding',
                            title: 'Secret Encoding',
                            message: `Secret contains non-base64 encoded data in key '${key}'`,
                            severity: 'Medium',
                            resource: secret.metadata?.name || 'Unknown',
                            kind: secret.kind || 'Unknown',
                            line: lineInfo.line,
                            column: lineInfo.column,
                            snippet: lineInfo.snippet,
                            remediation: 'Ensure all secret data is base64 encoded'
                        });
                    }
                });
            }
        }

        function checkConfigMapSecurity(configMap) {
            const lineInfo = findLineInfo(configMap, 'kind', 'ConfigMap');
            
            if (configMap.data) {
                Object.keys(configMap.data).forEach(key => {
                    SECRET_PATTERNS.forEach(p => {
                        if (p.regex.test(configMap.data[key])) {
                            addFinding({
                                id: 'ConfigMap-Secret',
                                title: 'Sensitive Data in ConfigMap',
                                message: `ConfigMap may contain sensitive data in key '${key}'`,
                                severity: 'High',
                                resource: configMap.metadata?.name || 'Unknown',
                                kind: configMap.kind || 'Unknown',
                                line: lineInfo.line,
                                column: lineInfo.column,
                                snippet: lineInfo.snippet,
                                remediation: 'Move sensitive data to Secrets'
                            });
                        }
                    });
                });
            }
        }

        function checkServiceAccountSecurity(sa) {
            const lineInfo = findLineInfo(sa, 'kind', 'ServiceAccount');
            
            if (sa.automountServiceAccountToken !== false) {
                addFinding({
                    id: 'ServiceAccount-Token',
                    title: 'Service Account Token',
                    message: 'ServiceAccount automatically mounts API credentials',
                    severity: 'Medium',
                    resource: sa.metadata?.name || 'Unknown',
                    kind: sa.kind || 'Unknown',
                    line: lineInfo.line,
                    column: lineInfo.column,
                    snippet: lineInfo.snippet,
                    remediation: 'Set automountServiceAccountToken to false'
                });
            }
        }

        function checkGenericResourceSecurity(resource) {
            const lineInfo = findLineInfo(resource, 'kind', resource.kind);
            
            if (resource.metadata && !resource.metadata.namespace && 
                resource.kind !== 'Namespace' && resource.kind !== 'ClusterRole' && 
                resource.kind !== 'ClusterRoleBinding') {
                addFinding({
                    id: 'Generic-Namespace',
                    title: 'Missing Namespace',
                    message: `${resource.kind} is not assigned to a namespace`,
                    severity: 'Low',
                    resource: resource.metadata?.name || 'Unknown',
                    kind: resource.kind || 'Unknown',
                    line: lineInfo.line,
                    column: lineInfo.column,
                    snippet: lineInfo.snippet,
                    remediation: 'Specify a namespace for the resource'
                });
            }
        }

        function checkGenericYamlSecurity(doc) {
            const lineInfo = findLineInfo(doc, 'kind', 'Generic');
            scanSecrets(doc);
        }

        function addFinding(finding) {
            findings.push({
                id: finding.id,
                title: finding.title,
                message: finding.message,
                severity: finding.severity,
                resource: finding.resource,
                kind: finding.kind,
                line: finding.line,
                column: finding.column,
                snippet: finding.snippet,
                remediation: finding.remediation
            });
        }

        function addAutoFix(resource, patch) {
            let fix = autoFixes.find(f => 
                f.resource.metadata?.name === resource.metadata?.name && 
                f.resource.kind === resource.kind
            );
            
            if (!fix) {
                fix = {
                    resource: JSON.parse(JSON.stringify(resource)),
                    patches: []
                };
                autoFixes.push(fix);
            }
            
            fix.patches.push(patch);
        }

        function findLineInfo(obj, key, value) {
            try {
                const jsonString = JSON.stringify(obj);
                const searchString = `"${key}":${JSON.stringify(value)}`;
                const index = originalConfig.indexOf(searchString);
                
                if (index === -1) {
                    return { line: 'N/A', column: 'N/A', snippet: 'N/A' };
                }
                
                const linesBefore = originalConfig.substring(0, index).split('\n');
                const line = linesBefore.length;
                const column = linesBefore[linesBefore.length - 1].length + 1;
                
                const startLine = Math.max(0, line - 2);
                const endLine = Math.min(configLines.length, line + 2);
                const snippet = configLines.slice(startLine, endLine).join('\n');
                
                return { line, column, snippet };
            } catch (e) {
                return { line: 'N/A', column: 'N/A', snippet: 'N/A' };
            }
        }

        function renderResults() {
            const resultsDiv = document.getElementById('results');
            const summaryDiv = document.getElementById('summary');
            
            if (findings.length === 0) {
                resultsDiv.innerHTML = '<div class="finding">No security issues found!</div>';
                summaryDiv.innerHTML = '<div class="summary-card"><div class="summary-item"><div class="summary-count">0</div><div class="summary-label">Findings</div></div></div>';
                return;
            }
            
            const severityCounts = {
                Critical: 0,
                High: 0,
                Medium: 0,
                Low: 0,
                Info: 0
            };
            
            findings.forEach(f => severityCounts[f.severity]++);
            
            summaryDiv.innerHTML = `
                <div class="summary-card">
                    <div class="summary-item Critical">
                        <div class="summary-count">${severityCounts.Critical}</div>
                        <div class="summary-label">Critical</div>
                    </div>
                    <div class="summary-item High">
                        <div class="summary-count">${severityCounts.High}</div>
                        <div class="summary-label">High</div>
                    </div>
                    <div class="summary-item Medium">
                        <div class="summary-count">${severityCounts.Medium}</div>
                        <div class="summary-label">Medium</div>
                    </div>
                    <div class="summary-item Low">
                        <div class="summary-count">${severityCounts.Low}</div>
                        <div class="summary-label">Low</div>
                    </div>
                    <div class="summary-item Info">
                        <div class="summary-count">${severityCounts.Info}</div>
                        <div class="summary-label">Info</div>
                    </div>
                </div>
            `;
            
            let tableHTML = `
                <table>
                    <thead>
                        <tr>
                            <th>Severity</th>
                            <th>ID</th>
                            <th>Title</th>
                            <th>Resource</th>
                            <th>Kind</th>
                            <th>Location</th>
                            <th>Message</th>
                            <th>Remediation</th>
                        </tr>
                    </thead>
                    <tbody>
            `;
            
            findings.forEach(finding => {
                const location = finding.line !== 'N/A' ? `Line ${finding.line}` : 'N/A';
                
                tableHTML += `
                    <tr class="${finding.severity}">
                        <td>${finding.severity}</td>
                        <td>${finding.id}</td>
                        <td>${finding.title}</td>
                        <td>${finding.resource}</td>
                        <td>${finding.kind}</td>
                        <td>${location}</td>
                        <td>${finding.message}</td>
                        <td>${finding.remediation}</td>
                    </tr>
                    <tr class="snippet-row">
                        <td colspan="8">
                            <pre>${finding.snippet || 'N/A'}</pre>
                        </td>
                    </tr>
                `;
            });
            
            tableHTML += `
                    </tbody>
                </table>
            `;
            
            resultsDiv.innerHTML = tableHTML;
        }

        function renderAutoFixes() {
            const fixesDiv = document.getElementById('autoFixes');
            
            if (autoFixes.length === 0) {
                fixesDiv.innerHTML = '<div>No automatic fixes available</div>';
                return;
            }
            
            let fixesHTML = '<h3>Suggested Fixes</h3>';
            
            autoFixes.forEach(fix => {
                fixesHTML += `<h4>${fix.resource.kind}: ${fix.resource.metadata?.name || 'Unknown'}</h4>`;
                fixesHTML += '<ul>';
                
                fix.patches.forEach(patch => {
                    fixesHTML += `<li><code>${patch.op} ${patch.path}: ${JSON.stringify(patch.value)}</code></li>`;
                });
                
                fixesHTML += '</ul>';
            });
            
            fixesDiv.innerHTML = fixesHTML;
        }

        function downloadCSV() {
            if (findings.length === 0) {
                alert('No findings to export');
                return;
            }
            
            const csvData = findings.map(f => ({
                Severity: f.severity,
                ID: f.id,
                Title: f.title,
                Resource: f.resource,
                Kind: f.kind,
                Location: f.line !== 'N/A' ? `Line ${f.line}` : 'N/A',
                Message: f.message,
                Remediation: f.remediation,
                Snippet: f.snippet || 'N/A'
            }));
            
            const csv = Papa.unparse(csvData);
            const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
            const url = URL.createObjectURL(blob);
            const link = document.createElement('a');
            link.href = url;
            link.download = 'k8s_security_findings.csv';
            link.click();
            URL.revokeObjectURL(url);
        }

        function downloadExcel() {
            if (findings.length === 0) {
                alert('No findings to export');
                return;
            }
            
            const excelData = findings.map(f => [
                f.severity,
                f.id,
                f.title,
                f.resource,
                f.kind,
                f.line !== 'N/A' ? `Line ${f.line}` : 'N/A',
                f.message,
                f.remediation,
                f.snippet || 'N/A'
            ]);
            
            const wb = XLSX.utils.book_new();
            const ws = XLSX.utils.aoa_to_sheet([
                ['Severity', 'ID', 'Title', 'Resource', 'Kind', 'Location', 'Message', 'Remediation', 'Snippet'],
                ...excelData
            ]);
            
            XLSX.utils.book_append_sheet(wb, ws, 'Security Findings');
            XLSX.writeFile(wb, 'k8s_security_findings.xlsx');
        }

        function downloadAutoFixes() {
            if (autoFixes.length === 0) {
                alert('No automatic fixes available');
                return;
            }
            
            const fixedResources = autoFixes.map(fix => {
                const resource = JSON.parse(JSON.stringify(fix.resource));
                
                fix.patches.forEach(patch => {
                    const pathParts = patch.path.split('/').filter(p => p);
                    let current = resource;
                    
                    for (let i = 0; i < pathParts.length - 1; i++) {
                        const part = pathParts[i];
                        
                        if (part.startsWith('[') && part.endsWith(']')) {
                            const selector = part.substring(1, part.length - 1);
                            const [key, value] = selector.split('=');
                            current = current.find(item => item[key] === value);
                        } else {
                            current = current[part];
                        }
                    }
                    
                    const lastPart = pathParts[pathParts.length - 1];
                    switch (patch.op) {
                        case 'add':
                        case 'replace':
                            current[lastPart] = patch.value;
                            break;
                        case 'remove':
                            delete current[lastPart];
                            break;
                    }
                });
                
                return resource;
            });
            
            const fixedYaml = fixedResources.map(r => jsyaml.dump(r)).join('---\n');
            
            const blob = new Blob([fixedYaml], { type: 'text/yaml' });
            const url = URL.createObjectURL(blob);
            const link = document.createElement('a');
            link.href = url;
            link.download = 'k8s_security_fixes.yaml';
            link.click();
            URL.revokeObjectURL(url);
        }
    </script>
</body>
</html>
